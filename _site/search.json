[
  
    {

      "title"    : "How I managed my time effectively",
      "url"      : "/posts/linux-freebsd-windows",
      "content"  : ""

    },
  

  
    {

      "title"    : "Leetcode",
      "url"      : "/notes/LeetCode",
      "content"  : "739. Daily Temperatures (Medium)12345678910111213141516171819202122class Solution:    def dailyTemperatures(self, T: List[int]) -&gt; List[int]:        class Node:            def __init__(self, data=-1, index=-1, parent=None):                self.data = data                self.index = index                self.parent = parent        answer = [None] * len(T)        current = Node()        for i, ele in reversed(list(enumerate(T))):            # print(\"ele\",ele,\"current\",current.data,current.index)            while current.index != -1 and ele &gt;= current.data:                # print(\"go back\")                current = current.parent            if(current.index != -1):                # print(\"update (\"+str(i)+\") with\",current.index - i)                answer[i] = current.index - i            else:                # print(\"update (\"+str(i)+\") with\",0)                answer[i] = 0            current = Node(ele,i,current)        return answer2. Add Two Numbers (Medium)12345678910111213141516171819202122value1 = 0        next1 = l1        i = 0        while(next1 != None):            value1 += next1.val*(10**i)            i+=1            next1=next1.next        value2 = 0        next2 = l2        i = 0        while(next2 != None):            value2 += next2.val*(10**i)            i+=1            next2=next2.next        value3 = value1 + value2        tmpv=str(value3)        tmpl=len(str(value3))        nextv=None        for i in range(0,tmpl,1):            nextv = ListNode(int(tmpv[i]),nextv)        return nextv1. Two Sum (Easy)123456789101112131415161718192021222324252627282930313233343536class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        answer = []        x = 0        y = len(nums)-1        ref = {}        # ref =&gt; {}        # [a,b,c,d]        # ref['a'] = 0        # ref['b'] = 1        # ref['c'] = 2        # ref['d'] = 3        for index, value in enumerate(nums):            if value not in ref:                ref[value] = index            else:                if(type(ref[value]) == list):                    ref[value].append(index)                else:                    ref[value] = [ref[value], index]                                nums = sorted(nums)        while True:            if(nums[x] + nums[y] &gt; target):                y = y - 1             elif(nums[x] + nums[y] &lt; target):                x = x + 1            elif(nums[x] + nums[y] == target):                if(nums[x] == nums[y]):                    answer = [ref[nums[x]][0], ref[nums[y]][1]]                else:                    answer = [ref[nums[x]], ref[nums[y]]]                break            elif(x == y):                break        return answer12345678class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        for i in range(0,len(nums),1):            for j in range(len(nums)-1,-1,-1):                if(i == j):                    break                if(nums[i] + nums[j] == target):                    return [i, j]3. Longest Substring Without Repeating Characters (Medium)1234567891011121314151617181920class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        tmp = {}        longest_length = 0        for i, c in enumerate(s):            if c not in tmp.keys():                tmp[c] = i            else:                if(longest_length &lt; len(tmp)):                    longest_length = len(tmp)                new_tmp = {}                start_position = tmp[c] + 1                for char, j in tmp.items():                    if(j &gt;= start_position):                        new_tmp[char] = j                new_tmp[c] = i                tmp = new_tmp        if(longest_length &lt; len(tmp)):            longest_length = len(tmp)        return longest_length 15. 3Sum (Medium)1234567891011121314151617181920212223242526272829class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        answer = []        if(len(nums) &gt; 2):            a = 0            b = a + 1            c = len(nums)-1            nums = sorted(nums)            while a != len(nums) - 2 or b &lt; c:                if a == 0 or a &gt; 0 and nums[a - 1] != nums[a]:                    while b &lt; c:                        if(nums[a] + nums[b] + nums[c] &gt; 0):                            c = c - 1                         elif(nums[a] + nums[b] + nums[c] &lt; 0):                            b = b + 1                        else:                            answer.append([nums[a], nums[b], nums[c]])                            b = b + 1                            c = c - 1                            while b &lt; c and nums[b] == nums[b-1]:                                b = b + 1                            while b &lt; c and nums[c] == nums[c+1]:                                c = c - 1                a = a + 1                b = a + 1                c = len(nums)-1                                    return answer18. 4Sum (Medium)12345678910111213141516171819202122232425262728293031323334class Solution:    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:        answer = []        if(len(nums) &gt; 3):            a = 0            b = a + 1            c = b + 1            d = len(nums)-1            nums = sorted(nums)            while a != len(nums) - 3:                if a == 0 or a &gt; 0 and nums[a - 1] != nums[a]:                    b = a + 1                    c = b + 1                    d = len(nums)-1                    while b != len(nums) - 2 or c &lt; d:                        if b == a+1 or b &gt; a+1 and nums[b - 1] != nums[b]:                            while c &lt; d:                                if(nums[a] + nums[b] + nums[c] + nums[d] &gt; target):                                    d = d - 1                                 elif(nums[a] + nums[b] + nums[c] + nums[d] &lt; target):                                    c = c + 1                                else:                                    answer.append([nums[a], nums[b], nums[c], nums[d]])                                    c = c + 1                                    d = d - 1                                    while c &lt; d and nums[c] == nums[c-1]:                                        c = c + 1                                    while c &lt; d and nums[d] == nums[d+1]:                                        d = d - 1                        b = b + 1                        c = b + 1                        d = len(nums)-1                a = a + 1            return answer1431. Kids With the Greatest Number of Candies1234567891011121314151617class Solution:    def kidsWithCandies(self, candies: List[int], extraCandies: int) -&gt; List[bool]:        maxVal = -1                # get max value        for i in candies:            if(maxVal &lt; i):                maxVal = i                        answer = []        # checker        for i in candies:            if(i+extraCandies &lt; maxVal):                answer.append(False)            else:                answer.append(True)        return answer1128. Number of Equivalent Domino Pairs (Easy)12345678910111213141516171819import mathclass Solution:    def numEquivDominoPairs(self, dominoes: List[List[int]]) -&gt; int:        counter = 0        tmp = []        count = {}                for dominoe in dominoes:            dominoe.sort()            if (dominoe[0],dominoe[1]) in count:                count[(dominoe[0],dominoe[1])] += 1            else:                count[(dominoe[0],dominoe[1])] = 1                        for _, val in count.items():            if(val &gt; 1):                counter += math.floor((val*(val-1))/2)                        return counter"

    }
  
]
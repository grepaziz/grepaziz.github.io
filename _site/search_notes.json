[
  
    {

      "title"    : "LeetCode",
      "url"      : "/notes/leetcode",
      "category" : "note",
      "tags"     : "",
      "content"  : "739. Daily Temperatures (Medium)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nclass Solution:\n    def dailyTemperatures(self, T: List[int]) -&gt; List[int]:\n        class Node:\n            def __init__(self, data=-1, index=-1, parent=None):\n                self.data = data\n                self.index = index\n                self.parent = parent\n        answer = [None] * len(T)\n        current = Node()\n        for i, ele in reversed(list(enumerate(T))):\n            # print(\"ele\",ele,\"current\",current.data,current.index)\n            while current.index != -1 and ele &gt;= current.data:\n                # print(\"go back\")\n                current = current.parent\n            if(current.index != -1):\n                # print(\"update (\"+str(i)+\") with\",current.index - i)\n                answer[i] = current.index - i\n            else:\n                # print(\"update (\"+str(i)+\") with\",0)\n                answer[i] = 0\n            current = Node(ele,i,current)\n        return answer\n\n\n2. Add Two Numbers (Medium)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nvalue1 = 0\n        next1 = l1\n        i = 0\n        while(next1 != None):\n            value1 += next1.val*(10**i)\n            i+=1\n            next1=next1.next\n        value2 = 0\n        next2 = l2\n        i = 0\n        while(next2 != None):\n            value2 += next2.val*(10**i)\n            i+=1\n            next2=next2.next\n        value3 = value1 + value2\n        tmpv=str(value3)\n        tmpl=len(str(value3))\n        nextv=None\n        for i in range(0,tmpl,1):\n            nextv = ListNode(int(tmpv[i]),nextv)\n\n        return nextv\n\n\n1. Two Sum (Easy)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        answer = []\n        x = 0\n        y = len(nums)-1\n        ref = {}\n        # ref =&gt; {}\n        # [a,b,c,d]\n        # ref['a'] = 0\n        # ref['b'] = 1\n        # ref['c'] = 2\n        # ref['d'] = 3\n        for index, value in enumerate(nums):\n            if value not in ref:\n                ref[value] = index\n            else:\n                if(type(ref[value]) == list):\n                    ref[value].append(index)\n                else:\n                    ref[value] = [ref[value], index]\n                        \n        nums = sorted(nums)\n        while True:\n            if(nums[x] + nums[y] &gt; target):\n                y = y - 1 \n            elif(nums[x] + nums[y] &lt; target):\n                x = x + 1\n            elif(nums[x] + nums[y] == target):\n                if(nums[x] == nums[y]):\n                    answer = [ref[nums[x]][0], ref[nums[y]][1]]\n                else:\n                    answer = [ref[nums[x]], ref[nums[y]]]\n                break\n            elif(x == y):\n                break\n        return answer\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        for i in range(0,len(nums),1):\n            for j in range(len(nums)-1,-1,-1):\n                if(i == j):\n                    break\n                if(nums[i] + nums[j] == target):\n                    return [i, j]\n\n\n3. Longest Substring Without Repeating Characters (Medium)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        tmp = {}\n        longest_length = 0\n        for i, c in enumerate(s):\n            if c not in tmp.keys():\n                tmp[c] = i\n            else:\n                if(longest_length &lt; len(tmp)):\n                    longest_length = len(tmp)\n                new_tmp = {}\n                start_position = tmp[c] + 1\n                for char, j in tmp.items():\n                    if(j &gt;= start_position):\n                        new_tmp[char] = j\n                new_tmp[c] = i\n                tmp = new_tmp\n        if(longest_length &lt; len(tmp)):\n            longest_length = len(tmp)\n        return longest_length \n\n\n15. 3Sum (Medium)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass Solution:\n    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:\n        answer = []\n        if(len(nums) &gt; 2):\n            a = 0\n            b = a + 1\n            c = len(nums)-1\n            nums = sorted(nums)\n            while a != len(nums) - 2 or b &lt; c:\n                if a == 0 or a &gt; 0 and nums[a - 1] != nums[a]:\n                    while b &lt; c:\n                        if(nums[a] + nums[b] + nums[c] &gt; 0):\n                            c = c - 1 \n                        elif(nums[a] + nums[b] + nums[c] &lt; 0):\n                            b = b + 1\n                        else:\n                            answer.append([nums[a], nums[b], nums[c]])\n                            b = b + 1\n                            c = c - 1\n                            while b &lt; c and nums[b] == nums[b-1]:\n                                b = b + 1\n                            while b &lt; c and nums[c] == nums[c+1]:\n                                c = c - 1\n                a = a + 1\n                b = a + 1\n                c = len(nums)-1\n                    \n        \n        return answer\n\n\n18. 4Sum (Medium)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:\n        answer = []\n        if(len(nums) &gt; 3):\n            a = 0\n            b = a + 1\n            c = b + 1\n            d = len(nums)-1\n            nums = sorted(nums)\n            while a != len(nums) - 3:\n                if a == 0 or a &gt; 0 and nums[a - 1] != nums[a]:\n                    b = a + 1\n                    c = b + 1\n                    d = len(nums)-1\n                    while b != len(nums) - 2 or c &lt; d:\n                        if b == a+1 or b &gt; a+1 and nums[b - 1] != nums[b]:\n                            while c &lt; d:\n                                if(nums[a] + nums[b] + nums[c] + nums[d] &gt; target):\n                                    d = d - 1 \n                                elif(nums[a] + nums[b] + nums[c] + nums[d] &lt; target):\n                                    c = c + 1\n                                else:\n                                    answer.append([nums[a], nums[b], nums[c], nums[d]])\n                                    c = c + 1\n                                    d = d - 1\n                                    while c &lt; d and nums[c] == nums[c-1]:\n                                        c = c + 1\n                                    while c &lt; d and nums[d] == nums[d+1]:\n                                        d = d - 1\n                        b = b + 1\n                        c = b + 1\n                        d = len(nums)-1\n                a = a + 1\n            return answer\n\n\n1431. Kids With the Greatest Number of Candies\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -&gt; List[bool]:\n        maxVal = -1\n        \n        # get max value\n        for i in candies:\n            if(maxVal &lt; i):\n                maxVal = i\n                \n        answer = []\n        # checker\n        for i in candies:\n            if(i+extraCandies &lt; maxVal):\n                answer.append(False)\n            else:\n                answer.append(True)\n        return answer\n\n\n1128. Number of Equivalent Domino Pairs (Easy)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nimport math\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -&gt; int:\n        counter = 0\n        tmp = []\n        count = {}\n        \n        for dominoe in dominoes:\n            dominoe.sort()\n            if (dominoe[0],dominoe[1]) in count:\n                count[(dominoe[0],dominoe[1])] += 1\n            else:\n                count[(dominoe[0],dominoe[1])] = 1\n                \n        for _, val in count.items():\n            if(val &gt; 1):\n                counter += math.floor((val*(val-1))/2)\n                \n        return counter"

    } ,
  
    {

      "title"    : "DIGITAL IMAGE PROCESSING (CS 559)",
      "url"      : "/notes/digital-image-processing",
      "category" : "",
      "tags"     : "",
      "content"  : "Syllabus\n\nasdasd\n\nHand-written Notes"

    } 
  
]